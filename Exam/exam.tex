\documentclass[addpoints]{exam}
%\documentclass[12pt,addpoints,answers]{exam} % To print with answers
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{fancybox}
\usepackage{svg}
\usepackage{listings}
\usepackage{todonotes}
\usepackage[english,ngerman]{babel}
\lstset{basicstyle=\ttfamily,
  showstringspaces=false,
  showspaces=false,
  showtabs=false,
  showstringspaces=false,
  commentstyle=\color{red},
  keywordstyle=\color{blue}
}
\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}





\pagestyle{headandfoot}
\firstpageheadrule
\firstpageheader{Name:} { } {Systems-Development and Frameworks}
\firstpagefooter{}{Final Exam, Page \thepage\ of \numpages}
{}
\runningheader{Name:} { } {Systems-Development and Frameworks}
\runningfooter{}{Final Exam, Page \thepage\ of \numpages}
{}
\runningheadrule
\runningfootrule

%%%%% Cover page

\coverfirstpageheader{HTW Berlin \\ Angewandte Informatik}{\includesvg{logo}}{Systems-Development\\ and Frameworks}
\runningheadrule
\runningfootrule
\onehalfspacing
\newcommand{\tf}[1][{}]{%
\fillin[#1][0.25in]%
}

\begin{document}
%\maketitle
\pointsinmargin % To print points in margin
\boxedpoints   % or \bracketedpoints

\begin{coverpages}
\hrule
\hrule
\noindent
\begin{tabular}{@{}p{.4\textwidth}@{\hspace{2cm}}p{.4\textwidth}@{}}
  \\
Name:\enspace\hrulefill & Matrikelnummer:\enspace\hrulefill
\end{tabular}
\noindent
\vspace{5em}

\setlength{\fboxsep}{1em}
\noindent\fbox{
  \parbox{\textwidth - 2em}{
    Deine Note in der Endklausur sagt nichts über dein Talent als
    Fullstack-EntwicklerIn aus. Viele wesentliche Fähigkeiten können nicht in
    einer schriftlichen Prüfung bewertet werden, z.B. selbstständiges Lernen,
    Wissensvermittlung, Einfühlungsvermögen und Hilfsbereitschaft innerhalb des
    Teams.\\

    Der primäre Zweck der Endklausur ist es, eine formelle Anforderung der
    Universität zu erfüllen, nämlich zu einer quantifizierbare Metrik pro
    Teilnehmer zu finden.\\

    Abgesehen davon dient die Klausur als Motivation: Wenn du diesen Satz
    liest, dann bereitest du dich wahrscheinlich auf die Prüfung vor. In diesem
    Fall hat die Endklausur und die Probeklausur ihren Zweck erfüllt.

\begin{center}
Viel Erfolg! \\
Robert Schäfer
\end{center}

}}

\vspace{3em}
\begin{center}
\gradetable[h][questions]
% Or use \gradetable[v][questions]
\end{center}

\end{coverpages}

\begin{questions}


\question Project Management
      \todo[inline]{ Mentoring }
      \todo[inline]{ Knowledge transfer }
      \todo[inline]{ Code Reviews }
      \todo[inline]{ Testing }
      \todo[inline]{ Continous Integration }

\begin{parts}
  \part[1] Vervollständige den folgenden Satz:
  Das Motto unseres Kurses ist: ``Le\_\_n and S\_\_\_e''

  \part[1]
  Was ist der Busfaktor? Schreibe eine Definition auf.
  \fillwithdottedlines{4em}

  \part[1]
  Was ist besser? Ein möglichst hoher Busfaktor oder ein niedriger Busfaktor?
  \begin{choices}
  \choice Ein hoher Busfaktor ist besser.
  \choice Ein niedriger Busfaktor ist besser.
  \end{choices}

  \part[3]
  Wie kann der Wissenstransfer im Team gewährleistet werden?
  Nenne mindestens drei unterscheidbare Methodiken, die wir im Kurs kennen
  gelernt haben:
  \fillwithdottedlines{6em}

  \part[4]
  Wobei helfen automatisierte Software-Tests?

  Software-Tests helfen dabei:
  \begin{checkboxes}
  \choice Regressionen zu vermeiden
  \choice das Verhaltens der Anwendung zu dokumentieren
  \choice Abhängigkeiten im Quellcode zu erkennen und zu vermeiden
  \choice bei der Software-Architektur, etwa bei beim Design von Schnittstellen
  \choice bei der Wartung des Quellcodes, z.B. beim Refactoring
  \choice die Korrektheit des Quellcodes zu beweisen
  \choice sicherzustellen, dass die Anforderungen des Kunden bzw. Endbenutzers erfüllt sind
  \choice Aussagen über das Laufzeitverhalten zu treffen, z.B. Komplexitätsklassen von Algorithmen
  \end{checkboxes}

  \part
  Wir haben in unserem Kurs einen Software-Test als ``positiv'' definiert, wenn er
  fehlschlägt. (Also ähnlich wie ein ``positiver'' medizinischer Test, welcher
  aussagt, dass eine Testperson mit einer Krankheit infiziert sei.)

  Fehlerhafte Software-Tests können zu folgenden Problemen führen:
  \begin{choices}
    \choice Das Team verliert an Disziplin und das Vertrauen in Software-Testing.
      Es beginnt Änderungen am Quellcode zu akzeptieren, obwohl der Build-Server
      fehlgeschlagen ist.
    \choice Es kommt zu Verzögerungen beim Ausrollen der Anwendung (Deployment).
    \choice Die Endbenutzer können betroffene Funktionen der Anwendung nicht mehr nutzen.
    \choice Es können Sicherheitslücken entstehen.
  \end{choices}

  \begin{subparts}
    \subpart[2]
    Welche dieser Probleme entstehen durch ``falsch-positive'' Software-Tests?
    Auswahl: \fillin
    \subpart[2]
    Welche dieser Probleme entstehen durch ``falsch-negative'' Software-Tests?
    Auswahl: \fillin
  \end{subparts}

    \part[2]
    Mit welcher Technik kann man ``falsch-negative'' Tests vorbeugen? Anders
    gefragt: Wie kann man sicherstellen, dass ein Software-Test überhaupt einen
    Fehler aufzeigen würde?
    \fillwithdottedlines{4em}

\end{parts}


\question Git
  \todo[inline]{git rebase}
  \todo[inline]{git clean}
  \todo[inline]{git reflog}
  \todo[inline]{git reset}
  \todo[inline]{git blame}
  \todo[inline]{git remote}
  \todo[inline]{git checkout <REFERENCE> -- path/to/file}
  \todo[inline]{Difference between working tree and index}
  \todo[inline]{How to write better commit messages}
\begin{parts}

\part[1]
 What data is hashed in order to generate a git commit id? Enumerate at least three
 attributes.
\fillwithdottedlines{4em}

\part[2]
  Is \texttt{git reset <ID> --hard} reversible? If yes, how can you reverse it? If
  no, please explain why.
\fillwithdottedlines{8em}

\part[2]
  Is \texttt{git clean --force} reversible? If yes, how can you reverse it? If
  no, please explain why.
\fillwithdottedlines{8em}

\part
  \todo[inline]{We will do the following exercise the other way around: Instead
  of you writing down the git commands that produce a given history, I will give
  you some commands and your task is to draw the resulting git history.}
  Consider the following scenario: You forgot to create a feature branch and
  committed on branch \texttt{master} by accident.\\

  Now you want to create a pull request. In order to do that you create a new
  branch with:
  \begin{lstlisting}
  git checkout -b feature-branch
  \end{lstlisting}
  You can see your current git history in figure~\ref{fig:git:1}.

\begin{figure}[h]
  \centering
  \includesvg[width=0.8\textwidth]{git/1.svg}
  \caption{After \texttt{git checkout -b feature-branch}}
  \label{fig:git:1}
\end{figure}

\begin{subparts}
\subpart[1]
  What are the commands that produce a git history as shown in
  figure~\ref{fig:git:2}?\\
\fillwithdottedlines{8em}

\begin{figure}[h]
  \centering
  \includesvg[width=0.8\textwidth]{git/2.svg}
  \caption{Remove commits from \texttt{master}}
  \label{fig:git:2}
\end{figure}



\subpart[1]
  Consider your git history looks as shown in figure~\ref{fig:git:2}.
  On wich commit do you need to rebase in order to produce a git rebase log as
  shown in figure~\ref{fig:rebase-log} and finally a git history as shown
  in figure~\ref{fig:git:3}?
  \begin{lstlisting}
    git checkout feature-branch
    git rebase --interactive ....
  \end{lstlisting}

\begin{figure}[h]
  \centering
  \includesvg[width=0.8\textwidth]{git/3.svg}
  \caption{Commits contain changes of the commits on top of the respective nodes}
  \label{fig:git:3}
\end{figure}


  \subpart[2] How do you need to change the rebase log in
  figure~\ref{fig:rebase-log} to produce a git history as shown in
  figure~\ref{fig:git:3}?

  \begin{figure}[h]
    \begin{lstlisting}[language=bash]
    pick C      ..........................
    pick D      ..........................
    pick E      ..........................
    pick F      ..........................
    pick G      ..........................
    \end{lstlisting}
    \caption{Rebase log of your editor}
    \label{fig:rebase-log}
  \end{figure}

\end{subparts}

\end{parts}



\question Funktionale Programmierung

\begin{parts}
\part[2] Was sind ``higher order functions''?
\fillwithdottedlines{2em}

\part[2] Im folgenden Code-Beispiel wird eine Funktion namens
  \texttt{higherOrderFunction} deklariert, die Argumente der Funktion heißen
  \texttt{some, arguments, you, can} und \texttt{choose}. Bitte schreibe
  eine Implementierung, sodass die Funktion \emph{ganz offensichtlich} zu einer
  ``higher-order function'' wird.
\begin{lstlisting}[extendedchars=true,basicstyle=\footnotesize\ttfamily,language=JavaScript]
function higherOrderFunction(some, arguments, you, can, choose) {
  // Write down any implementation, which obviously turns this function into a
  // higher order function.
  // ...




 // return ?
 // If you want, return something
}
\end{lstlisting}

\part
  \todo[inline]{
    Lerne folgende Methoden auf \texttt{Array.prototype}:
      \texttt{forEach},
      \texttt{map},
      \texttt{find},
      \texttt{filter},
      \texttt{reduce}
  }

  Die folgenden Code-Beispiele enthalten unnötige temporäre Zustände. Zustände
  sind immer schlecht, weil sie mögliche Fehlerquellen sind. Wie können die
  folgenden Code-Beispiele umgeschrieben (refactored) werden, um die unnötigen
  Zustände zu eliminieren? Das Verhalten des Codes darf sich nicht verändern.
\begin{lstlisting}[extendedchars=true,basicstyle=\footnotesize\ttfamily,language=JavaScript]
function findNextId (){
  let lastId = 0;
  for (i = 0; i < data.todos.length; i++) {
      if (data.todos[i].id > lastId) {
          lastId = data.todos[i].id;
      }
  }
  lastId += 1;
  return lastId;
}
\end{lstlisting}
\makeemptybox{12em}

\begin{lstlisting}[extendedchars=true,basicstyle=\footnotesize\ttfamily,language=JavaScript]
function filterTodos(mok, userAuth) {
  var retArray = []

  for (var i = 0; i < mok.length; i++) {
      if (mok[i].userAuth == userAuth) {
          retArray.push(mok[i])
      }
  }
  return retArray
}
\end{lstlisting}
\makeemptybox{12em}

\begin{subparts}
  \subpart[3]
  Es gibt für jedes Code-Beispiel einen Punkt, wenn die richtige Funktion von
  \texttt{Array.prototype} ausgewählt wird.
  \subpart[3]
  Für jedes korrekte Refactoring eines Code-Beispiels gibt es einen weiteren
  Punkt. Geringfügige Syntax-Fehler führen zu keinem Punktabzug.
\end{subparts}
\end{parts}


\question Authorization and Authentication
\begin{parts}
\part[2]
  Was bedeuten die Begriffe ``Authorization'' und ``Authentication''? Erkläre,
  welche Aufgaben mit den Begriffen gemeint sind und grenze sie voneinander ab.
  \fillwithdottedlines{6em}
\part[1]
  Richtig oder Falsch: Die Nutzdaten (der Payload) eines JWT (JSON-Web-Token)
  werden verschlüsselt übertragen.
  \begin{choices}
    \choice Richtig
    \choice Falsch
  \end{choices}
\part[1]
  Richtig oder Falsch: Wenn der Schlüssel zur Überprüfung der Signatur der
  JSON-Web-Token erneuert wird, werden alle bis dahin ausgelieferten Token
  invalidiert. 
  \begin{choices}
    \choice Richtig
    \choice Falsch
  \end{choices}
\end{parts}

\question GraphQL and Apollo-Server

\begin{parts}
\part[7] Welche Probleme löst GraphQL in Bezug auf REST?
  \begin{checkboxes}
  \choice HTTP-Caching Mechanismen werden besser ausgenutzt .
  \choice Auf dem Client kann die Benutzeroberfläche automatisch aktualisiert werden.
  \choice Die Anzahl der Anfragen wird minimiert.
  \choice Die Menge der ausgetauschen Daten pro Anfrage (der Traffic) wird minimiert.
  \choice Die Anzahl der Datenbank-Abfragen wird minimiert.
  \choice Daten können in einer Graph-Datenbank gespeichert werden.
  \choice Der Server wird robuster gegenüber Denial-of-Service Angriffen.
  \end{checkboxes}
\part
  Die Methodensignatur eines resolvers enthält vier Argumente, nämlich
  \texttt{parent}, \texttt{args}, \texttt{context} und \texttt{resolveInfo}.
  \begin{subparts}
    \subpart[1]
    Sollte das Argument \texttt{context} in allen resolvern gleich sein?
    \begin{choices}
      \choice Ja
      \choice Nein
    \end{choices}
    \subpart[1]
    Wozu wird das Argument \texttt{resolveInfo} genutzt?
    \fillwithdottedlines{4em}
  \end{subparts}

  \part[2]
  Schau auf die Implementierung eines Apollo-Servers in
  Abbildung~\ref{fig:apollo-server}. Wenn wir die GraphQL Anfrage in
  Abbildung~\ref{fig:graphql-query} an den Server schicken, mit welcher Antwort
  reagiert der Server?
  \begin{figure}[h]
    \begin{lstlisting}[language=bash]
      query {
        allStudents(limit: 2) {
          id
          fullname(reverse: true)
        }
      }
    \end{lstlisting}
    \caption{Graphql query}
    \label{fig:graphql-query}
  \end{figure}
  \makeemptybox{12em}

  \part Was schreibt der Server als Ausgabe aufs Terminal? Schreibe die
  \texttt{console.log} Ausgaben auf. Folgende korrekte Angaben werden bewertet:
\begin{subparts}
  \subpart[1] Korrekte Auswahl, welche Log-Ausgaben überhaupt erreicht werden
  \subpart[1] Korrekte Anzahl aller Ausgaben
  \subpart[1] Korrekte Reihenfolge der Ausgaben
  \subpart[1] Korrekter Wert des Arguments \texttt{parent}
  \subpart[1] Korrekter Wert des Arguments \texttt{args}
\end{subparts}
\makeemptybox{18em}
\begin{figure}[h]
  \lstinputlisting[
    basicstyle=\footnotesize\ttfamily,
    numbers=left,
    numberstyle=\footnotesize,
    numbersep=3em,
    extendedchars=true,
    language=JavaScript
  ]{code/graphql/index.js}
  \caption{Apollo server implementation}
  \label{fig:apollo-server}
\end{figure}
\end{parts}


\question Neo4J
\begin{parts}

  \part
  Wie wird das relationale Datenmodell in ein graph-basiertes Datenmodell
  übertragen? Nimm als Beispiel eine Neo4J-Datenbank.
  \begin{subparts}
    \subpart[1] Der Name einer Tabelle wird zu: \fillin
    \subpart[1] Die Spalten in einer Tabelle werden zu: \fillin
    \subpart[1] Eine Zeile in einer Tabelle wird zu: \fillin
    \subpart[1] Fremdschlüssel zu anderen Tabellen werden zu: \fillin
  \end{subparts}

    \part
    Betrachte die \texttt{cypher} query:
    \begin{lstlisting}
    MATCH (node)-[*]->(yetAnotherNode) RETURN *
    \end{lstlisting}
    \begin{subparts}
      \subpart
      Was bedeutet der Stern in den eckigen Klammern im ``pattern'' dieser
      query?
      \fillwithdottedlines{4em}
      \subpart
      Ist so eine Anfrage auch in einer relationalen Datenbank mit SQL möglich?
      \begin{choices}
        \choice Ja
        \choice Nein
      \end{choices}
    \end{subparts}

  \part[2] Können in einer Neo4J Datenbank Fremdschlüssel auf fehlende Einträge
  zeigen? Solche Zeiger ins Leere heißen auch ``dangling pointer''. Begründe deine
  Antwort:
  \fillwithdottedlines{4em}

  \part[1] Wieviele ``Labels'' darf ein Knoten in einer Neo4J Datenbank haben?
  Antwort: \fillin

  \part[1] Wieviele ``Typen'' darf eine Beziehung in einer Neo4J Datenbank haben?
  Antwort: \fillin


  \part
  Consider the cypher statements:
  \begin{lstlisting}
  CREATE(romeo:Person {name: 'Romeo'})
  CREATE(juliet:Person {name: 'Juliet'})
  \end{lstlisting}
  Figure~\ref{fig:neo4j:graph-before-merge} shows how the graph looks initially.
  \begin{figure}[h]
    \centering
    \includesvg[width=0.2\textwidth]{./neo4j/before-merge.svg}
    \caption{Romeo and Juliet at the beginning of the story}
    \label{fig:neo4j:graph-before-merge}
  \end{figure}

  When you run the following statement:
  \begin{lstlisting}
  MERGE(:Person {name: 'Romeo'})-[:LOVES]->(:Person {name: 'Juliet'})
  \end{lstlisting}

  The graph looks like shown in figure~\ref{fig:neo4j:graph-after-merge}.
  \begin{figure}[h]
    \centering
    \includesvg[width=0.4\textwidth]{./neo4j/after-merge.svg}
    \caption{Oops, we have two Romeos and two Juliets now}
    \label{fig:neo4j:graph-after-merge}
  \end{figure}
  \begin{subparts}
    \subpart[1]
    How can you fix the cypher statement so that we don't get duplicate nodes?
    \makeemptybox{8em}
    \subpart[2]
    What has happened, why have duplicate records been created at all? Can you
    explain this?
    \fillwithdottedlines{8em}
  \end{subparts}
\end{parts}

\clearpage

\question VueJS and NuxtJS
\todo[inline]{VueJS: component composition pattern}
\todo[inline]{VueJS: data bindings and events}
\todo[inline]{VueJS: computed properties}
\todo[inline]{VueJS: watchers}
\todo[inline]{Nuxt: asyncData}
\todo[inline]{Nuxt: page components and routing}
\todo[inline]{SSR: JS globals e.g. `document` or `window`}

\begin{parts}
  \part[4]
  Zu den Vorteilen von client-seitig gerenderten ``Single-page-applications''
  gegenüber traditionellen server-seitig gerenderten Web-Anwendungen gehören
  unter anderem:
  \begin{checkboxes}
    \choice Weniger Last auf dem Server
    \choice Desktop-ähnliches Nutzererlebnis
    \choice Größerer Anteil Nutzdaten in der Kommunikation zwischen Client- und Server
    \choice Bessere Suchmaschinen-Optimierung
    \choice Kompatibilität mit älteren Browsern
  \end{checkboxes}

  \part[1] Was ist isomorpher Quellcode?
  \fillwithdottedlines{4em}

  \part[3]
  Welche dieser sog.\ ``JavaScript globals'' sollte in Quellcode vermieden werden,
  welcher auch von server-seitig vorgerenderten Web-Anwendungen ausgeführt wird:
  \begin{checkboxes}
    \choice \texttt{document}
    \choice \texttt{console}
    \choice \texttt{window}
  \end{checkboxes}

  \part[1] Zu welcher Art von Fehler kommt es, wenn man trotzdem einer dieser
  ``globals'' in einem NodeJS Prozess aufruft?
  \fillwithdottedlines{2em}

  \part
  Wirf einen Blick auf die Vue-Komponente im Code-Beispiel~\ref{fig:vue-example}.
  Wenn in den folgenden Teilaufgaben Änderung im Quelltext vorgenommen werden
  sollen, können diese direkt in die Abbildung eingepflegt werden.
  \begin{subparts}
    \subpart[1]
    Offenbar hat sich ein Fehler eingeschlichen. Eigentlich soll die Methode
    \texttt{handleClick} beim Klick auf den Knopf ausgelöst werden. Durch welche
    Änderung kann der Fehler behoben werden?
    \subpart[1]
    Wenn die Methode \texttt{handleClick} ausgelöst wird, welchen Wert hat dann
    \texttt{message}?

    Antwort: \fillin
    \subpart[2]
    Füge ein \texttt{<input>} Feld hinzu, dessen Texteingabe mit dem Zustand
    \texttt{message} verknüpft ist. Bei jeder Text-Eingabe soll sich also der
    Wert von \texttt{message} verändern.
    \subpart[2]
    Implementiere eine computed property namens \texttt{reversedMessage}, welche
    den String \texttt{message} umdreht. Tipp:
    \begin{lstlisting}
      someString.split('').reverse().join('')
    \end{lstlisting}
    Dreht eine lokale Variable \texttt{someString} herum.
    \subpart[1]
    Warum ist es eigentlich sinnvoll, \texttt{reversedMessage} als computed
    property zu implementieren?
    \fillwithdottedlines{4em}
    \subpart[1]
    Was spricht dagegen, \texttt{reversedMessage} als Zustand in \texttt{data}
    zu initialisieren und zur Laufzeit zu verändern?
    \fillwithdottedlines{4em}
    \subpart[1]
    Was spricht dagegen, es als Methode zu implementieren und als
    \texttt{reversedMessage()} im ``template'' aufzurufen?
    \fillwithdottedlines{4em}
  \end{subparts}
\begin{figure}[h]
  \centering
  \lstinputlisting[
    numbers=left,
    language=HTML
  ]{code/vuejs/Example.vue}
  \caption{Eine kleine VueJS-Komponente}
  \label{fig:vue-example}
\end{figure}
\end{parts}

\clearpage

\question Fullstack testing and Requirements Engineering
\todo[inline]{Benefits and drawbacks of fullstack testing}
\todo[inline]{Common pitfalls of fullstack testing, e.g. timeouts and checking non-existing HTML elements}
\todo[inline]{User story template - who, what, why?}
\todo[inline]{Cucumber scenarios and readability}
\begin{parts}
  \part[1] Im Kurs haben wir die ``Testing-Pyramide'' und den
  ``Testing-Diamanten'' kennengelernt. Beides sind Modelle, die eine
  Hilfestellung bieten sollen, um zu einem ausgewogenen Verhältnis der
  jeweiligen Test-Klassen zu finden.
  Welche Klasse von Tests hat laut dem ``Testing-Diamanten'' den größten Wert
  und sollte deshalb besonders oft implementiert werden?

  Antwort: \fillin

  \part[2] Für welchen Zweck nutzt man Cucumber Testing?
  \fillwithdottedlines{4em}

  \part[2] Die Schablone eine User-Story sieht wie folgt aus:
  \begin{lstlisting}
  As a <role>
  I want to do <feature>
  In order to <benefit>
  \end{lstlisting}
  Diese Schablone soll dazu dienen, dass man bei der Erfassung von Anforderungen
  bestimmte Informationen nicht vergisst, z.B. die Zielgruppe und den Grund für
  eine gewünschte Funktion. Warum ist es so wichtig, diese Informationen stets
  zu dokumentieren?
  \fillwithdottedlines{8em}
\end{parts}

\question CSS
\begin{figure}[h]
  \centering
  \lstinputlisting[
    numbers=left,
    language=HTML
  ]{code/css/example.html}
  \caption{Ein beispielhaftes HTML Dokument}
  \label{fig:example-html}
\end{figure}
\begin{parts}
\part[3]
  Welche HTML-Elemente werden bzw.\ welches HTML-Element wird in Abbildung~\ref{fig:example-html}
  mit den folgenden CSS Selektoren selektiert? Gib als Antwort Zeilennummern an:
  \begin{subparts}
    \subpart
    \begin{lstlisting}

    .login-form:first-child

    \end{lstlisting}

    Antwort: \fillin

    \subpart

    \begin{lstlisting}

    .login-form :first-child

    \end{lstlisting}

    Antwort: \fillin

    \subpart

    \begin{lstlisting}

    .login-form > :first-child

    \end{lstlisting}

    Antwort: \fillin
  \end{subparts}
\part[1]
 Mit welchen CSS-Selektor können alle Eingabefelder selektiert werden?

 Antwort: \fillin

\end{parts}


\question Code Review
\todo[inline]{I will use a VueJS component or an apollo server test as a
code example for the code review}
\begin{parts}
\part[10] Give a code review of the following pull request. Find and annotate
  issues in the code. You will get a point only if you can explain what the
  problem is. You can get another point if you can give a suggestion how to fix
  the problem. There are about 20 issues in the code example. It is enough if
  you can find 10 issues and explain the problem. Alternatively you can also
  find 5 issues, explain the problem \textbf{and} write down the source code as
  a suggestion to fix it. Anything in between is also possible.

\todo[inline]{Non-atomic test cases}
\todo[inline]{Mixing async/await with then/catch}
\todo[inline]{Not sanitizing strings and having a cypher injection vulnerability}
\todo[inline]{C-style for loop}
\todo[inline]{Writing 'should' in test case descriptions}
\todo[inline]{Not closing sessions}
\todo[inline]{Multiline string without backticks}
\todo[inline]{Using index literals or keys instead of array/object destructuring}
\todo[inline]{Merge objects with ... spread operator}
\todo[inline]{Secrets (e.g. API keys or SSH keys) checked into source code}
\todo[inline]{Not waiting for a promise to finish - tests pass before even checking a result}
\todo[inline]{Nested if-clauses instead of guard clauses}
\todo[inline]{Expose user listing in login resolver - slight security issue}
\todo[inline]{Clients cannot update their cache becaus types have no ID in type definitions}
\todo[inline]{Not using hard-coded values for expectations - danger of false negatives}

\end{parts}

\end{questions}
\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
